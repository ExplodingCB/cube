<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSS 3D Cube</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: black;
    }

    .scene {
      width: 100vw;
      height: 100vh;
      perspective: 1000px;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .cube {
      width: min(30vw, 30vh);
      height: min(30vw, 30vh);
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.1s ease;
    }

    .cube:hover {
      animation-play-state: paused;
    }

    .face {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0.75;
      border: 2px solid white;
      display: flex;
      box-sizing: border-box;
    }

    .front {
      background: rgba(0, 255, 0, 0.5);
      transform: translateZ(calc(min(15vw, 15vh)));
    }

    .back {
      background: rgba(255, 0, 0, 0.5);
      transform: rotateY(180deg) translateZ(calc(min(15vw, 15vh)));
    }

    .right {
      background: rgba(0, 255, 255, 0.5);
      transform: rotateY(90deg) translateZ(calc(min(15vw, 15vh)));
    }

    .left {
      background: rgba(255, 255, 0, 0.5);
      transform: rotateY(-90deg) translateZ(calc(min(15vw, 15vh)));
    }

    .top {
      background: rgba(255, 255, 255, 0.5);
      transform: rotateX(90deg) translateZ(calc(min(15vw, 15vh)));
    }

    .bottom {
      background: rgba(0, 0, 255, 0.5);
      transform: rotateX(-90deg) translateZ(calc(min(15vw, 15vh)));
    }

    /* We're not using keyframe animation anymore */

    /* Add responsive hover control */
    @media (hover: hover) {
      .scene:hover .cube {
        animation-play-state: paused;
      }
    }

    /* Allow user to control cube with mouse */
    .controls {
      position: fixed;
      bottom: 10px;
      left: 0;
      right: 0;
      text-align: center;
      color: white;
      font-family: Arial, sans-serif;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div class="scene">
    <div class="cube">
      <div class="face front"></div>
      <div class="face back"></div>
      <div class="face right"></div>
      <div class="face left"></div>
      <div class="face top"></div>
      <div class="face bottom"></div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const cube = document.querySelector('.cube');
      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };
      let rotationX = 0;
      let rotationY = 0;
      let rotationZ = 0;
      let autoRotate = true;
      let lastInteractionTime = Date.now();
      const inactivityTimeout = 3000; // 3 seconds until auto-rotation resumes
      
      // Momentum variables
      let momentumX = 0;
      let momentumY = 0;
      let dragSpeed = { x: 0, y: 0 };
      const friction = 0.95; // Higher value = less friction
      const momentumThreshold = 0.1; // Minimum momentum to continue spinning
      
      // Auto-rotation speeds (degrees per frame)
      let autoRotationSpeedX = 0.1;
      let autoRotationSpeedY = 0.2;
      let autoRotationSpeedZ = 0.05;
      
      // Initialize
      updateCubeRotation();
      
      // Animation frame for smooth rotation
      function animate() {
        if (autoRotate) {
          // Auto-rotation mode
          rotationX += autoRotationSpeedX;
          rotationY += autoRotationSpeedY;
          rotationZ += autoRotationSpeedZ;
        } else {
          // Momentum-based rotation after user interaction
          if (Math.abs(momentumX) > momentumThreshold || Math.abs(momentumY) > momentumThreshold) {
            rotationX += momentumY;
            rotationY += momentumX;
            
            // Apply friction to slow down
            momentumX *= friction;
            momentumY *= friction;
            
            // Reset the last interaction time while momentum is still active
            if (Math.abs(momentumX) > 0.5 || Math.abs(momentumY) > 0.5) {
              lastInteractionTime = Date.now();
            }
          }
        }
        
        updateCubeRotation();
        requestAnimationFrame(animate);
      }
      
      // Start animation loop
      animate();

      // Auto rotation check interval
      setInterval(() => {
        if (!autoRotate && Date.now() - lastInteractionTime > inactivityTimeout) {
          // Transfer any remaining momentum to initial auto-rotation speed
          const speedFactor = 0.1;
          autoRotationSpeedX = 0.1 + Math.abs(momentumY) * speedFactor;
          autoRotationSpeedY = 0.2 + Math.abs(momentumX) * speedFactor;
          
          autoRotate = true;
          momentumX = 0;
          momentumY = 0;
        }
      }, 100);

      // Function to update cube rotation based on current values
      function updateCubeRotation() {
        cube.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg) rotateZ(${rotationZ}deg)`;
      }

      // Track speed over time for momentum
      function updateDragSpeed(x, y) {
        dragSpeed = { x, y };
      }

      // Handle mouse events for dragging
      document.addEventListener('mousedown', (e) => {
        isDragging = true;
        previousMousePosition = { x: e.clientX, y: e.clientY };
        
        // Stop momentum and auto-rotation
        momentumX = 0;
        momentumY = 0;
        autoRotate = false;
        
        // Reset drag speed
        dragSpeed = { x: 0, y: 0 };
        
        lastInteractionTime = Date.now();
      });

      document.addEventListener('mouseup', (e) => {
        if (isDragging) {
          // Transfer drag speed to momentum on release
          momentumX = dragSpeed.x * 0.2; // Scale factor controls "throw" force
          momentumY = dragSpeed.y * 0.2;
        }
        
        isDragging = false;
        lastInteractionTime = Date.now();
      });

      // Track previous positions and timestamps for velocity calculation
      let lastPos = { x: 0, y: 0, time: 0 };
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const currentTime = Date.now();
        const deltaMove = {
          x: e.clientX - previousMousePosition.x,
          y: e.clientY - previousMousePosition.y
        };

        // Calculate instantaneous velocity
        if (lastPos.time > 0) {
          const dt = currentTime - lastPos.time;
          if (dt > 0) {
            const speedX = (e.clientX - lastPos.x) / dt * 10; // Scale up for better feel
            const speedY = (e.clientY - lastPos.y) / dt * 10;
            updateDragSpeed(speedX, -speedY); // Invert Y for correct rotation direction
          }
        }
        
        // Save position for next velocity calculation
        lastPos = { x: e.clientX, y: e.clientY, time: currentTime };
        
        // Update rotation based on mouse movement
        rotationX -= deltaMove.y * 0.5; // Reversed for natural feel
        rotationY += deltaMove.x * 0.5;
        
        updateCubeRotation();
        previousMousePosition = { x: e.clientX, y: e.clientY };
        lastInteractionTime = Date.now();
      });

      // Handle touch events for mobile
      document.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          isDragging = true;
          previousMousePosition = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          
          // Stop momentum and auto-rotation
          momentumX = 0;
          momentumY = 0;
          autoRotate = false;
          
          // Reset drag speed
          dragSpeed = { x: 0, y: 0 };
          lastPos = { x: 0, y: 0, time: 0 };
          
          lastInteractionTime = Date.now();
        }
      });

      document.addEventListener('touchend', (e) => {
        if (isDragging) {
          // Transfer drag speed to momentum on release
          momentumX = dragSpeed.x * 0.2; // Scale factor controls "throw" force
          momentumY = dragSpeed.y * 0.2;
        }
        
        isDragging = false;
        lastInteractionTime = Date.now();
      });

      document.addEventListener('touchmove', (e) => {
        if (!isDragging || e.touches.length !== 1) return;
        
        const touch = e.touches[0];
        const currentTime = Date.now();
        const deltaMove = {
          x: touch.clientX - previousMousePosition.x,
          y: touch.clientY - previousMousePosition.y
        };

        // Calculate instantaneous velocity
        if (lastPos.time > 0) {
          const dt = currentTime - lastPos.time;
          if (dt > 0) {
            const speedX = (touch.clientX - lastPos.x) / dt * 10; // Scale up for better feel
            const speedY = (touch.clientY - lastPos.y) / dt * 10;
            updateDragSpeed(speedX, -speedY); // Invert Y for correct rotation direction
          }
        }
        
        // Save position for next velocity calculation
        lastPos = { x: touch.clientX, y: touch.clientY, time: currentTime };

        // Update rotation based on touch movement
        rotationX -= deltaMove.y * 0.5; // Reversed for natural feel
        rotationY += deltaMove.x * 0.5;
        
        updateCubeRotation();
        previousMousePosition = { x: touch.clientX, y: touch.clientY };
        lastInteractionTime = Date.now();
        
        // Prevent scrolling while dragging
        e.preventDefault();
      });
    });
  </script>

</body>
</html>
